% THIS IS SIGPROC-SP.TEX - VERSION 3.1
% WORKS WITH V3.2SP OF ACM_PROC_ARTICLE-SP.CLS
% APRIL 2009
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V3.2SP
% LaTeX2e document class file for Conference Proceedings submissions.
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V3.2SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
% ---------------------------------------------------------------------------------------------------------------
% It is an example which *does* use the .bib file (from which the .bbl file
% is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission,
% you need to 'insert'  your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% Questions regarding SIGS should be sent to
% Adrienne Griscti ---> griscti@acm.org
%
% Questions/suggestions regarding the guidelines, .tex and .cls files, etc. to
% Gerald Murray ---> murray@hq.acm.org
%
% For tracking purposes - this is V3.1SP - APRIL 2009

\documentclass{acm_proc_article-sp}

\begin{document}

\title{A GUC-secure protocol for authenticated anonymous channels}
\subtitle{[Extended Abstract]
\titlenote{A full version of this paper is available as
\textit{Author's Guide to Preparing ACM SIG Proceedings Using
\LaTeX$2_\epsilon$\ and BibTeX} at
\texttt{www.acm.org/eaddress.htm}}}
%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{2} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
Alonso Gonz\'alez U. \titlenote{asdasdasd}\\
       \affaddr{asdasd}\\
       \affaddr{asdasda}\\
       \affaddr{asdasd}\\
       \email{alogonza@ing.uchile.cl}
% 6th. author
\alignauthor Charles Palmer\\
       \affaddr{Palmer Research Laboratories}\\
       \affaddr{8600 Datapoint Drive}\\
       \affaddr{San Antonio, Texas 78229}\\
       \email{cpalmer@prl.com}
}
% There's nothing stopping you putting the seventh, eighth, etc.
% author on the opening page (as the 'third row') but we ask,
% for aesthetic reasons that you place these 'additional authors'
% in the \additional authors block, viz.
\additionalauthors{Additional authors: John Smith (The Th{\o}rv{\"a}ld Group,
email: {\texttt{jsmith@affiliation.org}}) and Julius P.~Kumquat
(The Kumquat Consortium, email: {\texttt{jpkumquat@consortium.net}}).}
\date{30 July 1999}
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle

\newdef{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}

\begin{abstract}
This paper provides a sample of a \LaTeX\ document which conforms to
the formatting guidelines for ACM SIG Proceedings.
It complements the document \textit{Author's Guide to Preparing
ACM SIG Proceedings Using \LaTeX$2_\epsilon$\ and Bib\TeX}. This
source file has been written with the intention of being
compiled under \LaTeX$2_\epsilon$\ and BibTeX.

The developers have tried to include every imaginable sort
of ``bells and whistles", such as a subtitle, footnotes on
title, subtitle and authors, as well as in the text, and
every optional component (e.g. Acknowledgments, Additional
Authors, Appendices), not to mention examples of
equations, theorems, tables and figures.

To make best use of this sample document, run it through \LaTeX\
and BibTeX, and compare this source code with the printed
output produced by the dvi file.
\end{abstract}

% A category with the (minimum) three required fields
\category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

\terms{Theory}

\keywords{ACM proceedings, \LaTeX, text tagging} % NOT required for Proceedings

\section{Introduction}

\section{Cryptographic model}

We prove the security guarantees of our protocol in the Generalized Universal Composability (GUC) cryptographical
framework. The GUC framework \cite{conf/tcc/CanettiDPW07} is a generalization of the Universal composability
framework \cite{conf/focs/Canetti01}. Both frameworks models concurrent protocols, but the GUC framework also
models concurrent protocols sharing state between them. Before the GUC framework were proposed an alternative way
to model protocols sharing state in the UC framework was the use of JUC theorem, but this is not as general as
it only allows protocols sharing state among themselves. Instead the GUC framework models protocols sharing state with
unpredictable other protocols.\\
We first review the UC frameworks as the GUC framework is exactly as UC with some minor, but significant, modifications.

\subsection{The Universal Composability framework (UC)}
The UC framework is a methodology for a modularized designing and modularized proving the security of
\textit{real world} cryptographics protocols. The spirit of UC is to create a protocol and then abstract the
security one  want the protocol have into a idealized secure protocol. Then it must be shown that
executing the real or the idealized protocol is essentially the same, and then real protocol is as
secure as the idealized protocol.\\
Real world protocols are modeled as protocols running in a complete concurrent setting with many other protocols and
possibly distributed among many parties. As in the real world the protocol can be monitored and some participants
can have ``undesired" behavior, attempting with the desired security of the protocol. All the possible undesired behavior
executed by one machine, the real adversary $\mathcal{A}$. In an execution of the protocol the adversary can eavesdrop and
manipulate all the data sent from one  party to another, can corrupt some parties and then execute
arbitrary code on them. On the other hand the ideal protocol, called the ideal functionality usually denoted by
$\mathcal{F}$, runs in an ideal setting,
that is executed by a secure party and the monitoring is restricted. In the ideal world there exists an ideal adversary
$\mathcal{S}$ but it cannot
eavesdrop and is only allowed to stop or drop exchanged data. The setting where the ideal protocol is executed with the
real adversary is known as the \textit{real world}, and the setting where the ideal protocol is executed with the ideal
adversary is known as the \textit{ideal world}. In both worlds concurrent execution with arbitrary other protocols is
given by a special machine known as environment. In UC both the real an ideal protocol are analyzed isolated from other
possibly concurrent protocols. It is considered that all the externals protocols and the outside calls to the protocol
are are executed by the environment.
To ensure that the real protocol achieves
the desired security it must hold that that for any execution of the protocol in real world and for any adversarial
strategy (that is for all environments and all real adversaries) there exists an adversarial strategy with limited
resources (an ideal adversary) that has the same effect (the environment is not aware of any difference between the
two strategies).\\


We review formal definitions given in \cite{mnCompleto}. There Wikstr\"om introduces
a new machine to the UC framework, named the communication model.
The communication model is in charge of all aspects of the
communication in UC. This definition comes to simplify the definition of what the
adversary can do in an execution, in fact the only difference between the real and the ideal
adversary is the communication model. The introduction of a communication model
also makes unnecessary the use of session id's as the communication models are local to each protocol instance.

% Lo que sigue lo tome textual del paper de Wikstrom. No se si eso esta bien, pero
% me parece innecesario re redactarlo

\begin{definition}
An ITM-graph is a set $V = \{P_1, \ldots, P_t\} \subset \textrm{ITM}$ with a set of
links $E$ such that $(V, E)$ is a connected graph, and no $P_i$ is linked to any
machine outside $V$. Let ITMG be the set of ITM-graphs.\\
During the execution of an ITM-graph, at most one participant is active. An active
participant may deactivate itself and activate any of its neighbors, or it may halt, in
which case the execution of the ITM-graph halts.
\end{definition}

The real communication model models an asynchronous communication network, in which the
adversary can read, delete, modify, and insert any message of its choice. 

\begin{definition}
A real communication model $\mathcal{C}$ is a machine with a link $l_{P_i}$, to $P_i$
for $i = 1, \ldots, k$, , and a link $l_\mathcal{A}$ to a real adversary $\mathcal{A}$.
Its program is defined as follows.
\begin{enumerate}
  \item If $m$ is read on $l_s$ where $s \in \{P_1, \ldots, P_k\}$, then $(s, m)$ is
        written on $l_\mathcal{A}$ and $mathcal{A}$ is activated.
  \item If $(r, m)$ is read on $l_\mathcal{A}$, where $r \in \{P_1, \ldots, P_k\}$
        and $P_r$ is activated.
\end{enumerate}
\end{definition}

For simplicity
we avoid to explicitly call the real communication model. When in a real world
protocol we write "$P_i$ send $m$ to $P_j$`` we mean "$P_i$ send $(P_j,m)$ to
$\mathcal{C}$``.\\
The ideal communication model below captures the fact that the adversary may decide if
and when it would like to deliver a message from the ideal functionality to a
participant, but it can not read the contents of the communication between participants
and the ideal functionality.

\begin{definition}
An ideal communication model $\mathcal{C_I}$ is a machine with a link $l_{P_i}$, to
$P_i$ for $i = 1, \ldots, k$,
%a link $l_\mathtt{shared}$ to the ``outside world",
and links $l_\mathcal{F}$, and $l_\mathcal{S}$ to a (shared) ideal functionality $\mathcal{F}$
and an ideal adversary $\mathcal{S}$ respectively. Its program is defined as follows.
\begin{enumerate}
  \item If a message $m$ is read on $l_s$, where $s \in \{P_1, \ldots, P_k\}$,
        then $(s, m)$ is written on $l_\mathcal{F}$ and $\mathcal{F}$ is activated.
  \item If a message $(s, m)$ written on $l_\mathcal{F}$ is returned unaltered, $m$ is
        written on $l_s$. If not, any string read from $l_\mathcal{F}$ is interpreted
        as a list $((r_1, m_1), \ldots, (r_t, m_t))$, where $r_i \in \{\mathcal{S},
        P_1, \ldots, P_k\}$. For each $m_i$ a random string $\tau_i \in \{0, 1\}^n$ is
        chosen, and $(r_i, m_i)$ is stored under $(\tau_i)$. Then $((r_1, |m_1|, \tau_1),
        \ldots, (r_t, |m_t|, \tau_t))$, where $|m_i|$ is the bit-length of $m_i$, is
        written on $l_\mathcal{S}$ and $\mathcal{S}$ is activated.
  \item Any string read from $l_\mathcal{S}$ is interpreted as a pair $(b, \tau)$, where
        $b \in \{0, 1\}$ and $\tau$ is an arbitrary string. If $b = 1$ and $(r_i, m_i)$
        is stored in the database under the index $\tau$, $m_i$ is written on $l_{r_i}$
        and $r_i$ is activated. Otherwise $(\mathcal{S}, \tau)$ is written to
       $l_\mathcal{F}$ and $\mathcal{F}$ is activated.
%  \item If $(\mathtt{NewSession}, P'_1, \ldots, P'_{k'})$ is read from $l_\mathtt{shared}$,
%        $\mathcal{F}$ is a shared functionality, and $P_i \neq P_j$ for $i = 1, \ldots,
%        k \quad j = 1, \ldots, k'$ then let $\mathtt{shared} \leftarrow 1$. Else
%        ignore the input.
%  \item If $(s,m)$ is read on $l_\mathtt{shared}$, $\mathtt{shared} = 1$ and $s \neq P_i$
%        for $i = 1, \ldots, k$, then write $(s, m)$ to $l_\mathcal{F}$. Else ignore the
%        input
\end{enumerate}
\end{definition}

%The $l_\mathtt{shared}$ allows the environment to create protocols sharing state with
%the analyzed protocol through the shared functionality.\\
An adversary can normally corrupt some subset of the participants in a protocol. A
\textit{dummy participant} is a machine that given two links writes any message from
one of the links to the other. There may be many copies of the dummy participant.
Following Canetti we use the $\tilde{}$-notation, e.g. $\tilde{P}$, for dummy participants.
%Similarly we introduce \textit{dummy functionalities}, a dummy functionality exactly as the
%dummy participant but it have
\\
The ideal model below captures the ideal world, i.e. the environment
may indirectly interact with ideal functionalities and the ideal adversary $\mathcal{S}$
has some control over how the communication model behaves.

\begin{definition}
The ideal model is defined to be the map $\mathcal{I}:\textrm{ITM}^2 \times
\tilde{\textrm{ITM}}^* \to \textrm{ITMG}$, where $\mathcal{I}: (\mathcal{F}, \mathcal{S}
\tilde{P}_1, \ldots, \tilde{P}_k) \mapsto (V, E)$ is given by:
$$V = \{\mathcal{C_I}, \mathcal{F}, \mathcal{S}, \tilde{P}_1, \ldots, \tilde{P}_k\}$$
$$E = \{(\mathcal{S}, \mathcal{C_I}), (\mathcal{C_I}, \mathcal{F})\} \cup
\bigcup_{i = 1}^{k}\{(\tilde{P}_i, \mathcal{C_I})\}$$
\end{definition}

If $\tilde{\pi} = (\tilde{P}_1, \ldots, \tilde{P}_k)$, we write
$\mathcal{I}(\mathcal{S}, \tilde{\pi}^\mathcal{F})$ instead of $\mathcal{I}(\mathcal{F},
\mathcal{S}, \tilde{P}_1, \ldots, \tilde{P}_k)$ to ease notation.\\
The real model is supposed to capture the properties of the real world. The participants
may interact over the real communication model.\\

\begin{definition}
The real model is defined to be a map $\mathcal{R}:\textrm{ITM}^* \to \textrm{ITMG}$,
where $\mathcal{R}:(\mathcal{A}, P_1, \ldots, P_k) \mapsto (V, E)$ is given by:
$$V = \{\mathcal{C}, \mathcal{A}, P_1, \ldots, P_k\}$$
$$E = \{(\mathcal{A}, \mathcal{C})\}\cup\bigcup_{i=1}^k\{(P_i, \mathcal{C})\}$$
\end{definition}

Let $(V, E) = \mathcal{I}(\mathcal{F}, \mathcal{S}, \tilde{P}_1, \ldots, \tilde{P}_k)$.
Then we write $\mathcal{Z}(\mathcal{I}(\mathcal{F}, \mathcal{S}, \tilde{P}_1, \ldots,
\tilde{P}_k))$ for the ITM-graph $(V', E')$ defined by $V' = V \cup \{\mathcal{Z}\}$,
and $E' = E \cup \{(\mathcal{Z}, \mathcal{S})\} \bigcup_{i=1}^k \{(\mathcal{Z}, \tilde{P}_i)\}$.
We use the corresponding notation in the real model case.\\
A hybrid model is a mix between a number of ideal and real models, and captures the execution
of a real world protocol with access to some ideal functionalities. It is also a tool to
modularize security proofs. It may be viewed as if we ``glue" a number of ideal and real
models onto an original real model.

\begin{definition}
Suppose that we are given
$(V, E) = \mathcal{R}(\mathcal{A}, \pi)$, $\pi = (P_1, \ldots, P_k)$.
Let $(V_j, E_j) =
\mathcal{I}(\mathcal{S}_j,
            \tilde{\pi}^{\mathcal{F}_j}_j)$,
$\tilde{\pi}_j = (\tilde{P}_{j, 1}, \ldots, \tilde{P}_{j, k})$ for $j = 1, \ldots, t$,
and $(V_j, E_j) = \mathcal{R}(\mathcal{S}_j,\pi_j)$,
$\pi_j = (P_{j, 1}, \ldots, P_{j, k})$ for $j = t+1, \ldots, s$.\\
We denote by
$\mathcal{H}(
    \mathcal{A}^{
        \mathcal{S}_1,
        \ldots,
        \mathcal{S}_t},
    \pi^{
        \tilde{\pi}_1^{\mathcal{F}_1},
        \ldots,
        \tilde{\pi}_t^{\mathcal{F}_t},
        \pi_{t+1},
        \ldots,
        \pi_s})$
the hybrid model defined as the ITM-graph $(V', E')$, where
$$V' = V \cup \bigcup_{j=1}^t V_j \textrm{, and}$$
$$E' = 
    E
    \cup
    \bigcup_{j=1}^t E_j
    \cup
    \bigcup_{i=1}^k
        \left(
            \{(\mathcal{S}_i, \mathcal{A})\}
            \cup
            \bigcup_{j=1}^t \{(P_i, \tilde{P}_{j, i})\}
        \right)$$
Similarly as above we write
$\mathcal{Z}(
    \mathcal{H}(
        \mathcal{A}^{
            \mathcal{S}_1,
            \ldots,
            \mathcal{S}_t},
        \pi^{
            \tilde{\pi}_1^{\mathcal{F}_1},
            \ldots,
            \tilde{\pi}_t^{\mathcal{F}_t},
            \pi_{t+1},
            \ldots,
            \pi_s}))$
to denote the ITM-graph $(V'', E'')$ defined by 
$V'' = V \cup \{\mathcal{Z}\}$,
and 
$E'' = 
    E'
    \cup
    \{\mathcal{Z}, \mathcal{A}\}
    \cup 
    \cup \bigcup_{i=1}^k \{(\mathcal{Z}, P_i)\}$.
\end{definition}


The UC-security is given as the inability of the environment to distinguish between the two worlds.

\begin{definition}
A protocol $\pi$ is said to UC-realize an ideal functionality $\mathcal{F}$ if and only if for all environment
$\mathcal{Z}$, for all real world adversary $\mathcal{A}$ there exists an ideal world adversary $\mathcal{S}$
and a negligible function $\eta$ such the following holds
$$\left| \Pr[\mathcal{Z}(\mathcal{H}(\mathcal{A},\pi))=1] - 
	 \Pr[\mathcal{Z}(\mathcal{I}(\mathcal{S},\mathcal{F}))=1] \right| \leq \frac{1}{\eta}$$
\end{definition}

A protocol UC-realizing an ideal functionality $\mathcal{F}$ can be completely replaced by the ideal functionality,
and nobody can realize of it. The last is guaranteed by the \textit{Composition theorem}:



\begin{theorem}
Suppose that
$\pi^{
    \tilde{\pi_1^{\mathcal{F}_1}},
    \ldots,
    \tilde{\pi_t^{\mathcal{F}_t}}}$
is a protocol that UC-realize the ideal functionality $\tilde{\pi}^{\mathcal{F}}$. Let $\rho^\pi$
be a subroutine respecting protocol which calls the protocol $\pi$. Then execution of the protocol
$\rho^{\pi/\mathcal{F}}$ in
the $\mathcal{F}-hybrid$ model is indistinguishable from the execution of the protocol $\rho^\pi$
\end{theorem}

By $\rho^{\pi/\mathcal{F}}$ we refer to the same code of the protocol $\rho^\pi$, but all the calls to $\pi$
are replaced by calls to $\mathcal{F}$.\\
A subroutine respecting protocol is protocol with no shared state with other protocols and his importance
is discussed next.\\

\subsection{The Generalized UC framework (GUC)}
A restriction on protocols to be UC-secure is that it must be \textit{subroutine respecting} one. That is, the protocol
and all its subroutines must not provide input or output with another protocols. In other words the protocol
and the subroutines called by the protocol are independent of all other protocols and can't share state with
other protocols. If this restriction is not accomplished the the UC-theorem could not
hold.\\
One scenario where is not realistic to assume that protocols are subroutine respecting is when setup
assumptions are needed to UC-emulate the ideal functionality. For example consider the
case of zero knowledge, is known that is impossible to realize zero knowledge proofs without some setup
assumption like the common random string (CRS) when only the minority of the parties is honest 
%TODO: No estoy seguro si es la referencia correcta
\cite{CanKusLin06}.
In UC the CRS is modeled as an ideal functionality
$\mathcal{F}_{CRS}$ that publicizes a random string to all parties, and zero knowledge protocols are proved to
UC-realize an ideal zero knowledge functionality in the $\mathcal{F}_{CRS}$. The CRS can be considered a
shared variable between all protocols using it. Such ideal functionality (a trusted party) is obvious to be hard
to obtain in the real world, and for that
reason is unrealistic to be considered local to a single protocol session. In fact it must be considered
shared between the many zero knowledge protocols and possibly other protocols. In the case of a shared
$\mathcal{F}_CRS$ used for realizing a ZK protocol is shown in \cite{Pass03} that it leads to loose of
the natural deniability of a ZK protocol. Furthermore in \cite{journals/tcs/YaoYZ09} is shown that it
% Revisar estas frases
also could lead to the loose of general composability and the "Proof of knowledge" property.\\
In GUC protocols can be not subroutine respecting but $\bar{\mathcal{G}}-$\textit{subroutine respecting},
and it means that the protocol is subroutine respecting except that is allowed to call the \textit{shared
functionality} $\bar{\mathcal{G}}$.
GUC framework models $\bar{\mathcal{G}}$-subroutine respecting  protocols by allowing the environment to
impersonate dummy parties connected to the shared functionality. This
small change makes able to the environment to simulate protocols sharing state with the analyzed protocol.\\
The formal modification is done as follows. Consider the ITM-graph $(V, E)$ given by
$\mathcal{H}(
    \mathcal{A}^{\mathcal{S}_1, \ldots, \mathcal{S}_t},
    \pi^{
        \tilde{\pi}_1^{\mathcal{F}_1},
        \ldots,
        \tilde{\pi}_r^{\mathcal{F}_r},
        \tilde{\pi}_{r+1}^{
        \bar{\mathcal{G}}_{r+1}},
        \ldots,
        \tilde{\pi}_t^{\bar{\mathcal{G}}_t},
        \pi_{t+1},
        \ldots,
        \pi_s}))$,
we write $\mathcal{Z}(V, E)$ to denote the ITM-graph $(V'', E'')$ defined by $V'' = V \cup
\{\mathcal{Z}\}$, and $E'' = E' \cup \{\mathcal{Z}, \mathcal{A}\} \cup \bigcup_{i=1}^k
\bigcup_{j=r+1}^t \{(\mathcal{Z}, \tilde{P}_{i,j})\} \cup \bigcup_{i=1}^k \{(\mathcal{Z}, P_i)\}$.
We remark that the set links $\bigcup_{i=1}^k \bigcup_{j=r+1}^t \{(\mathcal{Z}, \tilde{P}_{i,j})\}$
Similarly as in UC one can define GUC realization of an ideal functionality with for
$\bar{\mathcal{G}}-$subroutine respecting protocols, and is also possible to demonstrate a composition
theorem for $\bar{\mathcal{G}}-$subroutine respecting protocols.

\subsection{Deniable authentication in the GUC framework}
Deniable authentication was first defined, outside the (G)UC framework, by Dwork, Nahor and Sahai in
\cite{DwoNaoSah04}. Several modifications and generalizations have been made since then, and here we consider
the definition given by Dodis, Katz, Smith and Walfish in \cite{conf/tcc/DodisKSW09}, since that is the one who
applies to a concurrent and distributed setting\\
Roughly speaking an authentication protocol is deniable if nobody can prove that a particular session of
the protocol is taking place or have ever took place. In \cite{conf/tcc/DodisKSW09} is shown that such property
can be achieved considering an on line judge who must decide who is he talking to: an informant who is observing
a real session of the authentication protocol, or a mis informant who do not have access to the real session of
the protocol but still try to convince the judge that the session is taking place. The protocol is said to be
an on-line deniable authentication protocol if for all judge and all informants there exist a mis informant such that
the judge can't distinguish from the informant and the mis informant with overwhelming probability.\\
In the
full version of \cite{conf/tcc/DodisKSW09} is demonstrated that this notion is equivalent to GUC-realize the
functionality $\mathcal{F}_{auth}$. They pointed out that in the GUC framework a protocol GUC-realizing
a functionality $\mathcal{F}$ is as deniable as $\mathcal{F}$. The ideal functionality $\mathcal{F}_{auth}$ is
``fully simulatable'', that means that the protocol can be completely simulated without the participation
of any party, then the functionality $\mathcal{F}_{auth}$ is deniable because the misinformant can simulate
$\mathcal{F}$ to. Because a judge can distinguish
from the real protocol, the ideal functionality and the simulated ideal functionality.\\
We refer to ``online deniability'' instead of ``online authentication deniability'' protocolos,
and the definition is similar to the one in \cite{conf/tcc/DodisKSW09}.
We consider a judge $\mathcal{J}$, an informant $\mathcal{I}$, misinformant $\mathcal{M}$ and a global
setup functionaly $\bar{\mathcal{G}}$. Instead of
just a sender and a receiver runnig a protocol we consider parties $P_1, \ldots, P_N$ running a
distributed protocol $\pi$.\\
In the \textit{real world} the judge $\mathcal{J}$ is informed by the misinformant
$\mathcal{M}$ who gives input to and witness the execution of the protocol $\pi$. We assume that if there is
need some kind of interaction between the parties and $\bar{\mathcal{G}}$ for the execution of the protocols
(for example the parties need to register in a PKI), is done by $\mathcal{J}$ by direct access to
$\bar{\mathcal{G}}$ (with this $\mathcal{J}$ can also simulate concurrent execution of other protocols).
We denote by $\mathrm{Real}_{\mathcal{J, I,\bar{\mathcal{G}}},\pi}(k)$
the output of a judge $\mathcal{J}$ when is
executed in the real world with informant $\mathcal{I}$, setup functionality $\bar{\mathcal{G}}$, and
protocol $\pi$ executed with security parameter $k$.\\
On the other hand is the \textit{simulated world}, there the misinformant $\mathcal{M}$
try to mimic the behaviour of a real execution of $\pi$, but with no access to parties
$P_1, \ldots, P_N$. We denote by $\mathrm{Sim}_{\mathcal{J, I,\bar{\mathcal{G}}}}(k)$
the output of a
judge $\mathcal{J}$ when is executed in the ideal world with misinformant $\mathcal{M}$,
setup functionality $\bar{\mathcal{G}}$, and with security parameter $k$.

\begin{definition}
We say that a protocol $\pi$ is online deniable if for all judge $\mathcal{J}$ and all informant
$\mathcal{I}$ there exists a misinformant $\mathcal{M}$ such that
$$
\mathrm{Real}_{\mathcal{J, I,\bar{\mathcal{G}}},\pi}
\approx
\mathrm{Sim}_{\mathcal{J, M,\bar{\mathcal{G}}}}.
$$
\end{definition}

Consequently, there is an equivalent result to the one on
\cite{conf/tcc/DodisKSW09}.

\begin{theorem}
Suppose that $\mathcal{F}$ is a functionality defining the a GUC secure
realization of a task executed in the $\bar{\mathcal{G}}$-hybrid model, if $\mathcal{F}$ is online
deniable and $\pi$ GUC-realizes $\mathcal{F}$ in the $\bar{\mathcal{G}}$-hybrid model
then $\pi$ is a deniable protocol.
\label{teo:guc_den}
\end{theorem}

\begin{proof}
The proof is based on the observation that any execution of the deniability real world experiment
can be simulated on a real world GUC execution, that is for all judge
$\mathcal{J}$ and all informant $\mathcal{I}$ there exist an environment $\mathcal{Z}$ and an adversary
$\mathcal{A}$ such that
$$
\mathrm{
    GEXEC
    ^{
        \bar{\mathcal{G}}
    }
    _{
        \mathcal{Z},
        \mathcal{A}},
        \pi
    }
\approx
\mathtt{Real}_{\mathcal{J, I,\bar{G}},\pi}
$$

Let $\mathcal{J}$ be a judge and $\mathcal{I}$ be an informant, then we define the environment
$\mathcal{Z^{J,I}}$ with acces to $\mathcal{D}$, the dummy adversary, such that the output of $\mathcal{Z}$
is equal to the output of $\mathcal{J}$.
The environment $\mathcal{Z^{J,I}}$ simulates $\mathcal{J}$ and $\mathcal{I}$
with a link between $\mathcal{J}$ and $\mathcal{I}$, and links between $\mathcal{I}$ and a dummy party copy
$\tilde{P}_i$ for each party $P_i$ in $\pi$.
When a dummy party $\tilde{P}_i$ outputs $m$
$\mathcal{Z^{J,I}}$ send $m$ to $P_i$; when the dummy party informs something, $\mathcal{Z^{J,I}}$ make it happens
with the simulated dummy parties. $\mathcal{Z^{J,I}}$ return wathever $\mathcal{J}$ returns. The views of the simulated
$\mathcal{J}$ and $\mathcal{I}$ are the same than the real views, the the output of $\mathcal{Z^{J,I}}$ is
indistinguishable from the output of the real $\mathcal{J}$.\\
By hypotesis there exists a simulator $\mathcal{S}$ such that
$$
\mathrm
{
    GEXEC
    ^{
        \bar{\mathcal{G}}
     }
    _{
        \mathcal{Z},
        \mathcal{A},
        \pi
     }
}
\approx
\mathrm
{
    GEXEC
    ^{
        \bar{\mathcal{G}}
     }
    _{
        \mathcal{Z},
        \mathcal{A},
        \mathrm{IDEAL}_\mathcal{F}
     }
}
$$
and there exist a misinformant $\mathcal{M}$ such that
$$
\mathrm{Real}_{\mathcal{J, I,\bar{G}},\mathrm{IDEAL}_\mathcal{F}}
\approx
\mathrm{Sim}_{\mathcal{J, M,\bar{G}}}.
$$
We argue that the misinformant $\mathcal{S^M}$, resulting of the black-box composition of the
simulator $\mathcal{S}$ and the misinformant $\mathcal{M}$ is a misinformant for $\pi$. Indeed,
the view of $\mathcal{S}$ running with $\mathcal{M}$ must be the same view of $\mathcal{S}$
running with a dummy informant connected to $\mathrm{IDEAL}_\mathcal{F}$, otherwise $\mathcal{S}$
can be used as a judge to broke deniability of $\mathcal{F}$. 
\end{proof}

We note that a GUC execution is just a sintactic transformation of the deniability real world execution.
In the proof of theorem \ref{teo:guc_den} we show that all deniability real world execution can be simulated
by a guc execution. Is easy to show that the other directon also holds, that is for all environment $\mathcal{Z}$
and all adversary $\mathcal{A}$ there exists a judge $\mathcal{J}$ and an informant $\mathcal{I}$ such that
$$
\mathtt{Real}_{\mathcal{J, I,\bar{G}},\pi}
\approx
\mathrm
{
    GEXEC
    ^{
        \bar{\mathcal{G}}
    }
    _{
        \mathcal{Z},
        \mathcal{A},
        \pi
     }
}.
$$
Indeed, is known that all $\mathcal{Z}$ and all $\mathcal{A}$ can be simulated with an environment $\mathcal{Z}'$
and the dummy adversary $\mathcal{D}$. With a judge $\mathcal{J_{Z'}}$ we simulate $Z'$, and with a fixed informant
$\bar{\mathcal{I}}$ that only forwards all messages from the environment to a party and informs to
$\mathcal{J_{Z'}}$ al the traffic it sees. Then the view of the simulated $\mathcal{Z'}$ is indistinguishable
from the view of the original one, and thus the outoput of the simulation is indistinguishable from real output.

\section{Anonymous Channels} \label{sect:AC}
% Para que quede mejor podria poner tu definicion de anonimato, pero consecuentemente deberia probar
% que la funcionalidad ideal F_aac cumple con una de las defs. Cosa que no he hecho
Anonymous channels allow users to exchange messages without revealing their identities. Several protocols
have been proposed in the literature for anonymous channels. The modern study of anonymous channels was
started in \cite{journals/cacm/Chaum81} with \textit{mix-nets}. In a mix-net protocol the vector of all
parties encrypted messages are sent trough a set of \textit{mixers}. Each mixer perform an operation on cyphertexts
(usually partial decryption or reencryption) and send a random permutation to the next mixer. Finally the
last mixer publish a permutation of the vector of parties messages. Several modifications have been proposed
to mix-nets since Chaum's seminal paper, increasing tolerance to dishonest parties, robustness and many other
desirable properties.\\
To realize our protocol we use the universal composable mix net proposed by Wikstr\"om in \cite{Wikstrom04a}.
We remark that we have modified the original construction of \cite{Wikstrom04a}, by demanding each mixer to
check in the bulletin board that there are at least $\kappa$ valid published cyphertexts before starting
to mix.
Bassically the mix-net proceeds as follows:

\begin{enumerate}

\item Each sender $P_i$ waits for mixers public keys and computes the product public key.
      Then each encrypt his message under the product public key, publish the cyphertext
      to a bulletin board an prove in zero knowledge that it is a valid cyphertext.
\item Each mix net $M_j$ $j\in{1, \ldots, k}$ discards all the published cyphertexts that
      are not valid, and if the number of valid published cyphertexts is less than $\kappa$,
      wait.\\
      If the number of valid published cyphertexts is at least $\kappa$ then, for $l = 1,
      \ldots, k$ if $l = j$ the mixer partially decrypt
      the list of cyphertexts obtained from the bulletin board, perform a randomly chosen
      permutation on the list of cyphertext, publish on the bulletin board and prove in
      zero knowledge that the published list is a random permutation of the previous list.
      If $l \neq j$ the mixer must check that the permutation published by the mixer $M_l$
      is a valid one. Finally lexicographically sort the final published list and output it.

\end{enumerate}


In \cite{Wikstrom04a} is shown that this protocol UC-realize the ideal functionality $\mathcal{F}_{MN}$,
a slightly different functionality than the defined in figure \ref{func:F_MN}, in the
$\mathcal{F}_{KG}-hybrid$ model. Our modified mix-net UC-realizes the ideal functionality
$\mathcal{F}_{MN}^\kappa$ in the $\mathcal{F}_{KG}-hybrid$ model.

\begin{theorem}
There exists a protocol that UC-realizes the ideal functionality $\mathcal{F}_{MN}^\kappa$ in the
$\mathcal{F}_{KG}$-hybrid model with respect to static adhversaries that only corrupt half of
the mixers and under the DDH assumption in a ciclyc group $G_q$.
\label{teo:mixnet}
\end{theorem}

\begin{figure}
\framebox{\begin{minipage}[t]{1\columnwidth}
The Ideal functionality $\mathcal{F}_{MN}^\kappa$ running with mixers $M_{1}, \ldots, M_{k}$, senders
$P_{1}, \ldots, P_{N}$, and ideal adversary $\mathcal{S}$
\begin{enumerate}
    \item Initialize a list $L = \emptyset$, and sets $J_P = \emptyset$ and $J_M = \emptyset$.
    \item Suppose $(P_{i}, \mathtt{Send}, m_{i})$  $m_{i} \in G_q$ is received from $\mathcal{C_I}$.
          If $i\notin J_P$, set $J_P \leftarrow J_P \cup \{i\}$, and append $m_i$ to the list $L$. Then
          hand $(\mathcal{S}, P_i, \mathtt{Sent})$ to $\mathcal{C_I}$.
    \item Suppose $(M_{j}, \mathtt{Run})$ is received from $\mathcal{C_I}$. Set
          $J_M \leftarrow J_M \cup \{j\}$. If $|J_M | \geq k/2$ and $|J_P | \geq \kappa$ then sort the
          list $L$ lexicographically to form a list $L'$, and hand
          $((\mathcal{S}, M_{j}, \mathtt{Output}, L'), \{M_l , \mathtt{Output}, L'\}_{l=1}^{k})$ to
          to $\mathcal{C_I}$. Otherwise, hand $\mathcal{C_I}$ the list $(\mathcal{S}, M_{j}, \mathtt{Run})$
\end{enumerate}
\end{minipage}}
\caption{The functionality $\mathcal{F}_{MN}$}
\label{func:F_MN}
\end{figure}

We argue that the equivalent result for theorem \ref{teo:mixnet} in \cite{Wikstrom04a} implies
theorem \ref{teo:mixnet}. Consider a UC real world execution of our modified mix-net
protocol with the dummy adversary, and consider a class evironments $\mathcal{C}$ where each
$\mathcal{Z}\in\mathcal{C}$ corrupt less than $k/2$ mixer running arbitrary code on them, and instructs
parties to send at least $\kappa$ valid messages and before honest mixers send run. Clearly
for this class of environments both, the construction of \cite{Wikstrom04a} an our modificated
construction, give the same view to each environment in $\mathcal{C}$. Then the simulator
from \cite{Wikstrom04a} is still useful.\\
Now the question is:
Will this hold for environments outside the class $\mathcal{C}$?. Indeed, because each
environment $\mathcal{Z}'\notin\mathcal{C}$ can be simulated with another environment
$\mathcal{Z}\in\mathcal{Z}$. The environment $\mathcal{Z}$ postpones all instruction from
$\mathcal{Z}$ to a honest mixer to start before at least $\kappa$ honest messages have been,
but tell to $\mathcal{Z}'$ that it really happen. sended. As long as the ``postponed'' mixer
is honest there is no difference between the simulated $\mathcal{Z}'$ and the real one (because
in one case the mixer(s) have received the $\mathtt{Run}$ input and is stopped, and in the
other case is just stopped), and hence the random variable resulting of executing $\mathcal{Z}$
have the same distribution of the one resulting of executing $\mathcal{Z}'$. Then, quantifying
above all environments in $\mathcal{C}$ is the same as quantifying above all environments, and
as we argued for each environment in $\mathcal{C}$ there exist a simulator such that it can
distinguish from the real protocol execution and the ideal funtionality execution.


\section{Anonymous Authenticated Channels}

\subsection{The $\mathcal{F}_{AAC}$ ideal functionality}
An ``anonymous authenticated channel'' should allow parties to send authenticated messages to any other party without
revealing their identities. We formally define an anonymous authenticated channel through the definition of an ideal
functionality called $\mathcal{F}_{AAC}$ (figure \ref{func:F_AAC}). The functionality $\mathcal{F}_{AAC}$ just reveals
the value of a sent message, but not the identities related to thath message. This holds while the receiver of the
message is not corrupt, but even in that situation the information revealed by $\mathcal{F}_{AAC}$ is completely
simulatable by any one. Then the adversary can not prove to any one else that somebody sent or received a
message.\\

\begin{figure}
\framebox{\begin{minipage}[t]{1\columnwidth}
Functionality $\mathcal{F}_{AAC}^\kappa$ running with shared functionality $\bar{\mathcal{G}}_{KRK}$
with party $P_1,\ldots,P_N$ and adversary $\mathcal{S}$ proceeds as follows 
\begin{enumerate}
    \item Initialize $\Gamma \leftarrow \emptyset$, $M \leftarrow \emptyset$.
    \item Suppose $(\tilde{P}_i, \mathtt{Send}, m_{i,j}, j)$ is received from $\mathcal{C_I}$, do:\\
    \begin{enumerate}
          \item If $\tilde{P}_i$ or $ \tilde{P}_j$ aren't registered in $\bar{\mathcal{G}}_{KRK}$
                then send $(\tilde{P}_i, \perp)$ to $\mathcal{C_I}$.
          \item If $\tilde{P}_j$ is corrupted then send $(\mathcal{S}, \mathtt{Corruptsend},
                \tilde{P}_i, \tilde{P}_j, m_{i,j})$
          \item Else, send  $(\mathcal{S}, \tilde{P}_i, \mathtt{Sent})$ and
                $(\tilde{P}_i, \mathtt{Sent}, m_{i,j}, \tilde{P}_j)$ to $\mathcal{C_I}$,
                and let $\Gamma \leftarrow \Gamma \cup \{(m_{i,j}, i, j)\}$ and
                let $M \leftarrow M \cup \{(m_{i,j})\}$.
    \end{enumerate}
    \item Once that $|M| = \kappa$, for each $j \in \{1, \ldots, N\}$ let the multiset
          $M_j = \{(m_{i,j}, i)|,(m_i, i, j) \in \Gamma\}$,
          send $(\tilde{P}_j, \mathtt{Messages}, M_j)$ to $\mathcal{C_I}$ and send
          $(\mathcal{S}, \mathtt{Messages}, M)$ to $\mathcal{C_I}$.
\end{enumerate}
\end{minipage}}
\caption{The ideal functionality $\mathcal{F}_{AAC}$}
\label{func:F_AAC}
\end{figure}

The last holds because functionality $\mathcal{F}_{AAC}$ is online deniable, guaranteed by lemma
\ref{lemma:aac_den}.

\begin{lemma}
The functionlity $\mathcal{F}_{AAC}$ is online deniable.
\label{lemma:aac_den}
\end{lemma}

\begin{proof}
For each informant $\mathcal{I}$ we construct a misinformant $\mathcal{M^I}$ that internally
simulates $\mathcal{I}$. The misinformant $\mathcal{M^I}$ forwards to the judge $\mathcal{J}$
all messages sent by the simulated $\mathcal{I}$ to the judge. We note
that with the input given by the simulated $\mathcal{I}$ to the parties (in this case readen
by $\mathcal{M^I}$), the misinformant can completely simulate $\mathcal{F}_{AAC}$ and hence
the messages sent by the simulated $\mathcal{I}$ to the judge are indistinguishable from
the messages sent by the real $\mathcal{I}$ to $\mathcal{J}$.
\end{proof}

\subsection{The SIGMIX protocol}
A first natural attempt to realize $\mathcal{F}_{AAC}$ notion is by simply combining an anonymous
channel and a protocol GUC-realizing the ideal functionality $\mathcal{F}_{CERT}$ of \cite{conf/csfw/Canetti04}.
But this attempt fails as the ideal functionality $\mathcal{F}_{CERT}$ allows all parties to verify the authenticity
of a pair $(m, \sigma)$. This brings loose of anonymity by publicly binding the identity of the sender of $m$ with
$(m, \sigma)$.

With this in mind, providing anonymity and authenticity seems to be contradictory at first sight.
But, being more careful, we note that it can be realized if:
\begin{enumerate}
    \item The messages are signed.
    \item Only the receiver can prove if the party $P_i$  is the author of an authenticated message.
    \item The receiver can't prove to anybody else if $P_i$ is the author of the received message.
    \item The sending of messages is done in an anonymous way.
\end{enumerate}

To proceed, we use a modified version of the GUC-secure authentication protocol with respect to static adversaries, from
\cite{conf/tcc/DodisKSW09}. Noting that they use a deniable signing process that help us to achieve pointis 1, 2
and 3 of our
attempt to realize $\mathcal{F}_{AAC}$. The signing process is done through a signature that depends
not only on the content of message an the identity of the sender, instead it additionally depends on the identity
of the receiver allowing only the receiver to verify the authenticity of the pair $(m, \sigma)$. The point 4 is
achieved used the Wikstr\"om's mix net described in section \ref{sect:AC}.\\
%In the appendix we show that $\mathcal{F}_{AUTH}$ can be realized using $\mathcal{F}_{AAC}$ and in
%\cite{conf/csfw/Canetti04} is shown that no useful protocol can UC-realize $\mathcal{F}_{AUTH}$ in
%the bare model. This implies that $\mathcal{F}_{AAC}$ cannot be GUC-realized in the bare model. But, similarly as
%$\mathcal{F}_{AUTH}$, it can be realized in the $\bar{\mathcal{G}}_{KRK}-hybrid$ model with static adversaries.\\
The SIGMIX protocol runs in the $\mathcal{F}_{MN}, \bar{\mathcal{G}}_{KRK}-hybrid$ model with static adversaries.
The Key registration with knowledge $\bar{\mathcal{G}}_{KRK}$ shared functionality from \cite{conf/tcc/DodisKSW09}
(figure \ref{func:g_krk}) provides a PKI for any protocol running concurrently with the SIGMIX protocol. It is
stressed that any other protocol using $\bar{\mathcal{G}}_{KRK}-hybrid$ might share $(sk,pk)$ pairs with SIGMIX
as long as they don't publicize secret keys.
% Esto puede cambiar, pero tengo que verlo bien
On the other hand we consider the functionality $\mathcal{F}_{MN}$ as a traditional UC ideal functionality,
meaning that each instance of $\mathcal{F}_{MN}$ is local to each calling protocol.\\
To proceed with SIGMIX Each sender $P_i$ signs
a message $m_i$ to $P_j$ with a MAC using a shared secret key $k_{i,j}$ between $P_i$ and $P_j$.
Let $G_q$ a cyclic group of order $q$ where the Decisional Diffie-Hellman
assumption holds, and let $g$ a generator for $G_q$. Suppose that $P_i$ and $P_j$ have registered pairs of
secret key/public keys $(x_i, y_i=g^{x_i})$ and $(x_j, y_j=g^{x_j})$ such that $x_i, x_j \in G_q$.
Then the shared secret key $k_{i,j}$ can be non-interactively computed by $P_i$ with $k_{i,j}=y_j^{x_i}$ and by
$P_j$ with $k_{ij}=y_i^{x_j}$. The signed message $(m_i, \sigma_{i,j}=MAC_{k_{i,j}(m_i)})$ is sent to $P_j$
using the mix net and finally $P_j$ can check the authenticity recalculating the MAC. The SIGMIX protocol is
described in figure \ref{SIGMIX}.

\begin{figure}
\framebox{
\begin{minipage}[t]{1\columnwidth}
The protocol SIGMIX${}^\kappa$ running with parties $P_1,\ldots,P_N$ in the 
$\mathcal{F}_{MN}^\kappa, \bar{\mathcal{G}}_{KRK}-hybrid$ proceeds as follows:\\

%Registration. Each party $P_i$ registers as follows.
%\begin{enumerate}
%    \item Wait for input $(\mathtt{Register})$
%    \item Hand $(\mathtt{Retrieve}, P_i)$ to $\bar{\mathcal{G}}_{KRK}$ and let $(x_i, y_i)$
%          the answer.
%    \item If the answer was $(P_i, \perp)$ then let $x_i \overset{R}{\leftarrow} G_q$ and
%          $y_i \leftarrow g^{x_i}$. Hand $(\mathtt{register}, x_i)$ to $\bar{\mathcal{G}_{KRK}}$.
%\end{enumerate}

\textbf{Sender $P_i$:} Each sender $P_i$ proceeds as follows.
% Deberia haber una parametro para que el l-esimo haga que los mixers empiezen a funcionar
% Hasta el momento no estoy manejando los mixers y son parte de la interfaz de F_MN
\begin{enumerate}
    \item Wait for input $(\mathtt{Send}, P_j, m_{i,j})$.
    \item Let $x_i$ the secret key of $P_i$ registered on $\bar{\mathcal{G}}_{KRK}$. If $P_i$
          is not registered return $\perp$.
    \item Hand $(\mathtt{Retrieve}, P_j)$ to $\bar{\mathcal{G}}_{KRK}$ and let $y_j$ the answer.
    \item If the answer was $\perp$ then return $\perp$. Else compute $k_{i,j} \leftarrow y_j^{x_i}$
          and then compute $\sigma_{i,j} = \mathrm{MAC}_{k_{i,j}}(m_{i,j})$.
    \item Hand $(\mathtt{Send}, m_{i,j}||\sigma_{i,j})$ to $\mathcal{F}_{MN}$.
    \item Return $(\mathtt{Sent}, m_{i,j}, P_j)$
\end{enumerate}

\textbf{Receiver $P_j$:} Each receiver $P_j$ proceeds as follows.
\begin{enumerate}
    \item Wait for an input $(\mathtt{Output}, L)$ from $\mathcal{F}_{MN}$.
    \item Let $y_1, \ldots, y_N$ the public keys of all parties participating in
          the protocol. For each $i \in \{1, \ldots, N\}$ compute shared secret
          $k_{i,j} \leftarrow  y_{i}^{x_j}$
    \item Let the multiset $M_j \leftarrow \emptyset$. For each $(m, \sigma) \in L$
          and for each $k_{ij}$, if $\sigma = \mathrm{MAC}_{k_{ij}}(m)$ then
          $M_j \leftarrow M_j \uplus \{(m, i)\}$.
    \item Return $(\mathtt{Messages}, M_j)$.
\end{enumerate}

\textbf{Mixer $M_i$:} Each mixer send $(\texttt{Run})$ to $\mathcal{F}_{MN}$ at the begining
of the protocol execution. 

\end{minipage}}
\caption{The protocol SIGMIX}
\label{SIGMIX}
\end{figure}

\subsection{Proof of security}

Before we proove security of SIGMIX, we must prove the next proposition.

\begin{proposition}
Let $G_q$ be a cyclic group where the DDH assumption holds, then the multiparty
DDH (MDDH) assumption also holds, that is:
$$
(\{g^{x_i}\}_{i=1}^n, \{g^{x_ix_j}\}_{i,j=1, i\neq j}^n)
\overset{c}{\approx}
(\{g^{x_i}\}_{i=1}^n, \{g^{r_{i,j}}\}_{i,j=1, i\neq j}^n).
$$
Where $x_i\in_R G_q$, $r_{i,j} \in_R G_q$ for all $i$ and $j$.
\label{prop:mddh}
\end{proposition}

\begin{proof}
The proof is based on th next observation. Let 
$C = \{1, \dots, n\}^2 \setminus \{(i,i)\}_{i=1}^n$, let $\{S_i\}$ be an enumeration of $C$,
let $I_k = \bigcup_{i=1}^k\{S_i\}$ and $\bar{I}_k = C \setminus I_k$. Let the random variable
$$
\vec{\chi}_k=
(\{g^{x_i}\}_{i=1}^n,
 \{g^{r_{i,j}}\}_
 {
    (i,j) \in I_k
 },
 \{g^{x_ix_j}\}_
 {
    (i,j)\in \bar{I}_k\
 })
$$
where $x_i\in_R G_q$, $r_{i,j} \in_R G_q$ for all $i$ and $j$.
Then it must be that for all $i$
$$
\vec{\chi}_i \overset{c}{\approx} \vec{\chi}_{i+1}.
$$
By transitivity whe have that $\vec{\chi}_0 = \vec{\chi}_{|C|}$, and this implies proposition \ref{prop:mddh}.\\
To reach contradiction, suppose there exists an adversary $A$ such that there exists a polinomial $p$ and
for all $k$ large enough
\begin{equation}
\left| \Pr[A(\vec{\chi}_i)=1]-\Pr[A(\vec{\chi}_{i+1})=1] \right| \geq \frac{1}{p(k)}.
\label{eq:mddh}
\end{equation}
We construct an adversary $D^A$ that breaks DDH in $G_q$. The definition of $D^A$ is straightforward.
Let $S_{i+1} = (i^*, j^*)$,
given the input $(g^x, g^y, g^z)$ it
chooses $x_i \in_R G_q$ and $r_{i,j} \in_R G_q$  for all $i \neq i^*$ and $i \neq j^*$. $D$ computes
$$
\vec{\gamma}_1 =
(\{g^{x_i}\}_{i=1, i\neq i^*, i \neq j^*}^n),
$$
$$
\vec{\gamma}_2 =
(\{g^{x_ix_j}\}_
 {
    (i,j) \in I,
     i \neq i^*,
     j \neq j^*
 }),
$$
$$
\vec{\gamma}_3 =
(\{(g^x)^{x_i}\}_{i=1, i\neq i^*, i \neq j^*}^n),
$$
$$
\vec{\gamma}_4=
(\{(g^y)^{x_i}\}_{i=1, i\neq i^*, i \neq j^*}^n),
$$
and
$$
\vec{\gamma}_5=
(\{g^{r_{i,j}}\}_
 {
    (i,j)\in \bar{I}\
 }).
$$
And assign the vector 
$$
\vec{\chi} \leftarrow  
(
    \vec{\gamma}_1,
    g^x,
    g^y, 
    \vec{\gamma}_2,
    \vec{\gamma}_3,
    \vec{\gamma}_4,
    \vec{\gamma}_5,
    g^z
),
$$
run $A(\vec{\chi})$ and output wathever $A$ outputs.\\
The next equalities holds trivially:
$$
\Pr[D(g^x,g^y,g^{xy})=1] = \Pr[A(\vec{\chi}_i)=1]
$$
and
$$
\Pr[D(g^x,g^y,g^z)=1] = \Pr[A(\vec{\chi}_{i+1})=1].
$$
Replacing correspondent values in equation \ref{eq:mddh} contradicts that DDH holds in $G_q$.
\end{proof}

The security of SIGMIX is guaranteed by lemma \ref{lemma:sigmix}

\begin{lemma} 
The protocol SIGMIX GUC-emulates the ideal functionality $\mathcal{F}_{AAC}$ in the
$\mathcal{F}_{MN}, \bar{\mathcal{G}}_{KRK}-hybrid$ model with respect to static adversaries.
\label{lemma:sigmix}
\end{lemma}

\begin{proof}
\textit{(Lemma \ref{lemma:sigmix})}
The proofs proceed as follows: For each real adversary $\mathcal{A}$ we construct an ideal adversary
$\mathcal{S^A}$ who attacks $\mathcal{F}_{AAC}$,
if there exists an adversary $\mathcal{A}$ and an environment $\mathcal{Z}$ that distinguish an
execution of the protocol SIGMIX in the $\mathcal{F}_{MN}, \bar{\mathcal{G}}_{KRK}$-hybrid model
from an execution of $\mathcal{F}_{AAC}$ in the $\mathcal{F}_{MN}, \bar{\mathcal{G}}_{KRK}$-hybrid
model, then the Diffie-Hellman assumption or the unforgeability of MAC can be
broken.\\
Let $I_{\mathcal{A}} \subseteq \{1, \ldots, N\}$ be the set indexes of parties corrupted by $\mathcal{A}$
and let $I_{\mathcal{A}}^M \subseteq \{1, \ldots, k\}$ the set of indexes of mixers corrupted by $\mathcal{A}$.
The ideal adversary $\mathcal{S^A}$ is described in figure \ref{adv_S_A}, and it simulates
the execution of SIGMIX only with access to $\mathcal{F}_{AAC}$.\\
As the values of honest messages
(the sender and the receiver is honest) remains unknown to $\mathcal{S^A}$ until all
messages are sent, $\mathcal{S^A}$ cheats the simulated $\mathcal{A}$ making $\mathcal{F}_{MN}$ tells
$\mathcal{A}$ that the message was sent.
When the set of honest sent messages $M$ is revealed to $\mathcal{S^A}$, it
silently makes the simulated parties send the messages to $\mathcal{F}_{MN}$. This seems to $\mathcal{A}$
indistinguishable from an execution where an hypothetical adversary $\mathcal{S}'^{\mathcal{A}}$ guesses
the messages sent from $\mathcal{Z}$ to each honest party, as the strings seen by $\mathcal{A}$ are the
same in both experiments.
To simulate honest partys $\mathcal{S^A}$ 

\begin{figure}
\framebox{\begin{minipage}[t]{1\columnwidth}
Ideal adversary $\mathcal{S^A}$ running with parties $\tilde{P}_1, \ldots, \tilde{P}_N$
and executed in the $\mathcal{F}_{MN},\bar{\mathcal{G}}_{KRK}$-hybrid model proceeds as follows:\\

At the beginning $\mathcal{S^A}$ corrupts parties $\tilde{P}_i$ $i \in I_\mathcal{A}$ and
and mixers $M_i i\in I_\mathcal{A}^\mathcal{M}$, then simulates an execution of $\mathcal{Z}', \mathcal{A}$
and the parties $P_1, \ldots, P_N$ executing SIGMIX in the $\mathcal{F}_{MN},\bar{\mathcal{G}}_{KRK}$-hibrid
model. $\mathcal{Z}'$ is machine controlled by $\mathcal{S^A}$, and
$\bar{\mathcal{G}}_{KRK}$ and $\mathcal{F}_{MN}$ are honestly simulated with some minor
modifications.\\

Simulation of links $(\mathcal{Z}', \mathcal{A})$ with $(\mathcal{Z}, \mathcal{S})$:\\
If $m$ is received from $\mathcal{Z}$ then make $\mathcal{Z}'$ send $m$ to $\mathcal{A}$.
If $m$ is sent from $\mathcal{A}$ to $\mathcal{Z}'$ then send $m$ to $\mathcal{Z}$\\
Let $M_{corrupt} = \emptyset$.\\

Simulation of corrupted parties $\tilde{P}_i$ $i \in I_\mathcal{A}$:

\begin{enumerate}
\item If $P_i$ $i \in I_\mathcal{A}$ send $m||\sigma$ to $\mathcal{F}_{MN}$ and
      $\sigma = \textrm{MAC}_{y_j^{x_l}}(m)$ for some registered public key $y_j$ $j \in \{1, \ldots, N\}$
      and some registered secret key $x_l$ $l \in I_\mathcal{A}$, then send
      $(\mathtt{Send}, m, j)$ to $\tilde{P}_l$.
\item If $\sigma \neq \textrm{MAC}_{y_j^{x_l}}(m)$ for all
      registered public keys $y_j$ $j \in \{1, \ldots, N\}$ and all registered secret keys $x_l$
      $l \in I_\mathcal{A}$ do nothing.
\end{enumerate}

Simulation of honest parties $P_i$ $i \in I_\mathcal{A}$:
\begin{enumerate}
   
    \item If  $(\tilde{P}_i, \mathtt{Sent})$ is received from $\mathcal{F}_{MN}$ and $\tilde{P}_i$
          then make make $\mathcal{F}_{MN}$ sends
          $(\tilde{P}_i, \mathtt{Sent})$ to $\mathcal{A}$.
    \item If $(\texttt{Corruptsend}, \tilde{P}_i , \tilde{P}_j , m_{i,j})$ is received from $\mathcal{F}_{AAC}$
          make $\mathcal{Z'}$ sends to $\tilde{P}_i$ the message $(\mathtt{Send}, m, j)$. When $P_i$ ask for his
          secret key the simulated $\bar{\mathcal{G}}_{KRK}$ must answer $P_j$ secret key ($\mathcal{S^A}$
          knows it because $P_j$ corrupted), and when $P_i$ ask for $P_j$'s public key the simulated
          $\bar{\mathcal{G}}_{KRK}$ must answer $P_i$'s public key.
    \item Once $(\mathtt{Messages}, M)$ is received from $\mathcal{F}_{AAC}$ then modify the list
          $L$ of $\mathcal{F}_{MN}$ be equal to $M$.
\end{enumerate}
\end{minipage}}
\caption{The ideal adversary $\mathcal{S^A}$}
\label{adv_S_A}
\end{figure}

We define
$\mathrm{Real}(k) = 
\mathrm{GEXEC}_
{
    \mathcal{Z}
    \mathcal{A},
    \mathrm{SIGMIX}
}
^{
    \bar{\mathcal{G}}_{KRK},
    \mathcal{F}_{MN}
}(k)$
and
$\mathrm{Ideal}(k) = 
\mathrm{GEXEC}_
{
    \mathcal{Z}
    \mathcal{S^A},
    \mathrm{IDEAL}_{\mathcal{F}_{AAC}}
}
^{
    \bar{\mathcal{G}}_{KRK}
}
(k)$.
Suppose thath there exists an environment $\mathcal{Z}$, an adversary $\mathcal{A}$ and a polynomial $p$ such that
for all $k \geq k_0$:
\begin{equation}
\left| \Pr[\mathrm{Real}(k) = 1] - \Pr[\mathrm{Ideal}(k) = 1] \right| \geq \frac{1}{p(k)}.
\label{eq:guc}
\end{equation}

Then we can construct (figure \ref{adv:ddh}) the adversary $\mathcal{D}_{MDDH}$ that breaks MDDH.

\begin{figure}
\framebox{\begin{minipage}[t]{1\columnwidth}
The adversary $\mathcal{D}_{MDDH}(\{g^{x_i}\}_{i=1}^N, \{g^{r_{i,j}}\}_{i,j=1,i\neq j}^N)$ attacking
MDDH over $G_q$:\\

\begin{enumerate}
    \item Simulate an execution of SIGMIX with environment $\mathcal{Z}$ and adversary $\mathcal{A}$ in the
          $\mathcal{F}_{MN}, \bar{\mathcal{G}}_{KRK}$-hybrid model.
    \item When a the party $\tilde{P}_{i}$ $i \in \{1, \ldots, N\}$ registers on $\bar{\mathcal{G}}_{KRK}$ set
          the registered public key to $g^{x_i}$.
    \item If $\mathcal{Z}$ sends $(\mathtt{Send}, m, j)$ to $P_{i}$, replace $P_i$'s signature with
          $\mathrm{MAC}_{g^{r_{i,j}}}(m)$.
    \item When the simulation halts return wathever $\mathcal{Z}$ outputs.
\end{enumerate}
\end{minipage}}
\caption{The adversary $\mathcal{D}_{MDDH}$}
\label{adv:ddh}
\end{figure}

Note that as in the MDDH experiment $x_i \in_{R} G_q$ for all $i \in \{1, \ldots, N\}$ then it is undistinguishable
to the environment the modification made by $\mathcal{D}_{MDDH}$ when $r_{i,j} = x_ix_j$
\begin{equation}
\Pr[\mathrm{Real} = 1] = \Pr[\mathcal{D}_{MDDH}((\{g^{x_i}\}_{i=1}^N, \{g^{x_ix_j}\}_{i,j=1,i\neq j}^N) = 1].
\label{eq:ddh_1}
\end{equation}\\
Now, the only possible difference between executing $\mathcal{D}_{MDDH}$ when $r_{i,j} \in_R G_q$ and executing
Ideal lies on the possibility that $\mathcal{A}$ forges a signature for honest a receiver $P_j$ from a sender
$P_i$. Let $\mathcal{U}$ be the event where $\mathcal{A}$ forges at least one signature in the execution of
$\mathcal{D}_{MDDH}$ when $r_{i,j} \in_R G_q$. In figure \ref{adv:mac} we define
an adversary $\mathcal{D}_\mathrm{MAC}$ such that, if the probability of $\mathcal{U}$ happens is not
negligible (say $\frac{1}{p(k)}$, for $k$ large enough), then it brokes unforgeability of MAC. Indeed,
let $\mathcal{V}$ be the random variable wich
evalues to 1 if $\mathcal{D}_\mathrm{MAC}$ forges a signature in the UF-CMA experiment, and 0 if not:
$$
\Pr[\mathcal{V}=1] = \Pr[\mathcal{V}=1|\mathcal{U}]\Pr[\mathcal{U}] +
                     \Pr[\mathcal{V}=1|\bar{\mathcal{U}}]\Pr[\bar{\mathcal{U}}]
$$
$$
\Pr[\mathcal{V}=1] \geq \frac{1}{N(N-1)}\frac{1}{p(k)} +
                        0\left(1-\frac{1}{p(k)}\right)
$$
$$
\Pr[\mathcal{V}=1] \geq \frac{1}{N(N-1)p(k)}
$$
and $\Pr[\mathcal{V}=1]$ is not negligible, the it must be that $\Pr[\mathcal{U}]$ is
negligible.\\
Now, if $\mathcal{W} = \mathcal{D}_{MDDH}((\{g^{x_i}\}_{i=1}^N, \{g^{x_ix_j}\}_{i,j=1,i\neq j}^N)$, is
obvious that
$$
\Pr[\mathcal{W} = 1] = \Pr[\mathcal{W}=1|\bar{\mathcal{U}}] + \mu(k),
$$
where $\mu$ is a negligible function. 

\begin{figure}
\framebox{\begin{minipage}[t]{1\columnwidth}
The adversary $\mathcal{D}_\mathrm{MAC}$ attacking unforgeability of MAC with oracle access
to $\mathrm{MAC}_{k}$, $k\in_R G_q$:\\
\begin{enumerate}
    \item Simulate $\mathcal{D}_{MDDH}$'s execution of SIGMIX with $r_{i,j} \in_R G_q$.
    \item Choose $i^*,j^* \in_R \{1, \ldots, N\}\setminus I_\mathcal{A}$ and  let $M \leftarrow \emptyset$,
    \item Whenever the party $P_i$ calls MAC with key $g^{x_i^*x_j^*}$ replace the result
          with $\mathrm{MAC}_k(m)$ and let $M_1 \leftarrow M_1 \uplus \{m||\sigma\}$.
    \item When $\mathcal{F}_{MN}$ publish the list $L$ drop all messages $m||\sigma$ such that
          $\sigma = \mathrm{MAC}_{g^{x_ix_j}}(m)$, $i\neq i^*$ or $j \neq j^*$, and with
          the other messages form a list $L'$.
    \item If $L'\setminus M \neq \emptyset$ pick a random element in $L'\setminus M$ an return it.
    \item Else, abort.
\end{enumerate}
\end{minipage}}
\caption{The adversary $\mathcal{D}_\mathrm{MAC}$}
\label{adv:mac}
\end{figure}

is the output of honest parties. But if there exists an honest party with index $j$ such that $M_j^\mathrm{Real} \neq M_j^\mathrm{Ideal}$,
then there exists a pair $(m, l) \in M_j^\mathrm{Real}$. And it must hold that $(m, l) \notin M_j^\mathrm{Ideal}$ because the
same messages are sent in Real and Ideal, except for those dropped by $\mathcal{S^A}$ in step 1 of the simulation of corrupted
parties. The previous means that the adversary created a signature $\sigma \neq \mathrm{MAC}_{y_i^{x_l}}(m)$ for all $l \in I_\mathcal{A}$,
and as it was accepted by $P_j$ it must be that $\sigma = \mathrm{MAC}_{g^{\gamma r_i r_j}}(m)$ for some $i \notin I_\mathcal{A}$.
The latter contradicts unforgeability of MAC, then:
\begin{equation}
\Pr[\mathrm{Ideal} = 1] \approx \Pr[\mathcal{D}_{DDH} = 1|\gamma \in_R G_q]
\label{eq:ddh_2}
\end{equation}
Replacing equation \ref{eq:ddh_1} and \ref{eq:ddh_2} in \ref{eq:guc} contradicts the assumption that DDH holds in $G_q$.
\end{proof}

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{sigproc}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional
%\balancecolumns

\end{document}
